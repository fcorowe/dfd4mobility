<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.361">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>data-description</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="data-description_files/libs/clipboard/clipboard.min.js"></script>
<script src="data-description_files/libs/quarto-html/quarto.js"></script>
<script src="data-description_files/libs/quarto-html/popper.min.js"></script>
<script src="data-description_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="data-description_files/libs/quarto-html/anchor.min.js"></script>
<link href="data-description_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="data-description_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="data-description_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="data-description_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="data-description_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">



<section id="meta-facebook-data-introduction" class="level1">
<h1>Meta-Facebook data introduction</h1>
<section id="introduction-to-digital-footprint-data" class="level2">
<h2 class="anchored" data-anchor-id="introduction-to-digital-footprint-data">Introduction to digital footprint data</h2>
<p>A digital footprint refers to the trail of digital activities and information left by individuals as they interact with digital platforms and services. It encompasses data generated through online activities such as browsing history, social media interactions, location tracking, and other digital transactions. The cumulative collection of data forms a digital profile that provides insights into an individual’s online behavior, preferences, and activities. This data can also be aggregated to shed light into macro structural processes and trends, such as urban mobility, consumer demand, transport usage, population ageing and decline.</p>
<p>In particular, digital footprint data can be harnessed to analyse human mobility patterns, including patterns of internal mobility within a specific geographical area. By leveraging data from sources such as mobile devices, transportation apps, and geolocation services, we can gain a deeper understanding of how individuals move within a region. For example, digital footprint data can reveal the spatiotemporal patterns of commuting behaviour, the popularity of a certain route connecting two locations, the likelihood that a certain location experiences congestion at a certain time of the day, and even the impact of external factors such as weather conditions, public events or COVID-19 on mobility. Understanding human mobility patterns is therefore key to support fundamental human activities, including urban planning, transportation, service delivery, public health and sustainability.</p>
</section>
<section id="meta-facebook-as-a-source-of-digital-footprint-data" class="level2">
<h2 class="anchored" data-anchor-id="meta-facebook-as-a-source-of-digital-footprint-data">Meta-Facebook as a source of digital footprint data</h2>
<p>The social media platform Facebook, with its vast user base, offers unique advantages for analysing human mobility. In the course of providing services to their users, many smartphones and smartphone apps regularly collect precise location information. In the case of Facebook, people have an option of whether or not to provide this information to Facebook <span class="citation" data-cites="Facebook2023">[@Facebook2023]</span>. Location data is used to provide a variety of services, including helping people find nearby friends, information about nearby Wi-Fi hotspots, and location-relevant ads. This data also enables targeting of AMBER alerts and prompts to check-in as “safe” after a hazard event. In addition to powering Facebook product features, this location data can provide insights about how populations are affected by hazard events as they happen <span class="citation" data-cites="Maas19">[@Maas19]</span>.</p>
<p>Through Meta’s Data for Good programme, Facebook’s parent company, Meta Platforms Inc., provides tools built from privacy-protected data on the Facebook platform, as well as tools developed using commercially and publicly available sources like satellite imagery and census data. In particular, Data for Good has created two data sets, <a href="https://dataforgood.facebook.com/dfg/tools/facebook-population-maps">Facebook Population During Crisis</a> and <a href="https://dataforgood.facebook.com/dfg/tools/movement-maps#accessdata">Facebook Movement During Crisis</a>, that will be of use for this workshop.</p>
<p>These data sets make use of anonymised and aggregated data, including current and historical location data. While the raw data used for the creation of the data sets remains available only to the data owners, the aggregated data, with privacy and security protections is shared with non-profit organisations and researchers on an ongoing basis in the days and weeks following a hazard event <span class="citation" data-cites="Maas19">[@Maas19]</span>.</p>
</section>
<section id="datasets-description" class="level2">
<h2 class="anchored" data-anchor-id="datasets-description">Datasets description</h2>
<p>Both data sets Facebook Population and Facebook Movements contain data corresponding to a two-year period, starting in March 2020, and to four Latin American countries, Argentina, Chile, Colombia and Mexico.</p>
<p>The data in both data sets is temporally aggregated into three 8-hour windows (00:00–08:00, 08:00–16:00 and 16:00–00:00) for every day in the aforementioned two-year time period.</p>
<p>It is spatially aggregated into tiles according to the Bing Maps Tile System. This geospatial indexing system was developed by Microsoft and it partitions the world into square cells at various levels of resolution.</p>
<p>The Facebook Population data set provides information on the number of active Facebook users in each tile.</p>
<p>The data set Facebook Movements captures the total number of Facebook users moving between pairs of origin and destination Bing tiles.</p>
<p>We note here that due to the nature of the Facebook Movement data, we cannot distinguish between different types of movements, for example, daily commutes to work or permanent changes of address. However, we are still able to detect the evolution of movements between origin-destination pairs of Bing tiles and hence, we are able to capture the impact that COVID-19 has on mobility patterns.</p>
<p>On top of the data for the two-year period, each entry in the Facebook Population and Facebook Movements datasets include data for baseline levels before COVID-19. The baseline values are computed based on a 45-day period ending on the 10th of March of 2020.</p>
<p>The data sets also include a ‘quality’ score indicating the number of standard deviations by which the observed data at specific locations and time windows differ from the baseline values, hence highlighting statistically significant changes.</p>
<!-- An additional data set from WorldPop was used to capture the spatial distribution of population density in the different countries analysed here. -->
<!-- The dataset contains gridded population data at 1 sqkm resolution for the year X. -->
<!-- We aggregated the WorldPop population data into the Bing tiles in order to match the level of aggregation of the mobility data provided by Meta, and used it to estimate the population density of the Bing tiles. -->
<!-- Then, we classified the Bing tiles into 10 discrete categories of population density, hence obtaining a categorisation of Bing tiles a lot more detailed than the traditional binary rural/urban classification (Fielding, 1989). -->
<section id="methodology-for-data-set-desing" class="level3">
<h3 class="anchored" data-anchor-id="methodology-for-data-set-desing">Methodology for data set desing</h3>
<p>Prior to releasing the above-mentioned data sets, Meta applies three techniques to ensure privacy and anonymisation. First, a small undisclosed amount of random noise is added to ensure that precise location cannot be identified for small population counts in sparsely populated areas. While removing small counts may lead to an underrepresentation of the population in these places, the geographic distribution of population is still reflected in the data. Second, spatial smoothing is applied to produce a smooth population count surface using inverse distance-weighted averaging. Third, any remaining population counts of less than 10 are removed from the final data set (see Maas et al. <span class="citation" data-cites="Maas19">[@Maas19]</span> for details).</p>
</section>
</section>
<section id="challenges-of-digital-footprint-data" class="level2">
<h2 class="anchored" data-anchor-id="challenges-of-digital-footprint-data">Challenges of digital footprint data</h2>
<p>Despite the numerous advantages of using DFD to study the patterns of human mobility, the presence of biases in this type of data is usually regarded as a problematic issue. The biases in DFD usually stem from the fact that certain population groups may be more likely to use location-tracking technologies than others, for example, younger people or people living in urban areas. Therefore, DFD may not be representative of the entire population and as a result, the accuracy of analyses involving DFD may be hindered, especially when biases are not accounted for.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>