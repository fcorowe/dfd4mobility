# Spatial patterns {.unnumbered}

## Aims

## Dependencies

```{r}
#| warning: false
#| message: false

#clean environment
rm(list=ls())

# data wrangling
library(tidyverse)
#library(fs)
#library(here)

# spatial data wrangling
library(sf)
library(mapdeck)

# data visualisation
library(viridis) 
#library(viridisLite)
library(ggthemes)
library(patchwork)
library(showtext)
library(gganimate)
#library(gifski)
#library(ggnewscale)
```

## Data

### Meta-Facebook mobility data

Read and describe Meta-Facebook mobility data

Data for April 2020

```{r}
# read
df20 <- readRDS("./data/fb/movement_adm/2020_04.rds") %>% 
  dplyr::filter(country == "CL")
glimpse(df20)
```

```{r}
unique_origins <- unique(df20$start_polygon_name)
unique_destinations <- unique(df20$end_polygon_name)
```

### Bing tiles

Read and describe Bing tile grids and how they can be created - reference to our work.

R spatial ecosystem to handle spatial data frames.

```{r}
bing_grid <- read_sf("./data/shp/grid/chile_grid.shp") %>% 
  st_simplify(preserveTopology =T,
              dTolerance = 1000) %>%  # 1km
  sf::st_make_valid()
```

```{r}
#| echo: false
p_country <- ggplot(data = bing_grid) + 
  geom_sf(color = "gray60", 
          size = 0.1) +
  theme_void() +
  ggtitle('Chile')

p_north <- ggplot(data = bing_grid %>% tail(100) ) + 
  geom_sf(color = "gray60", 
          size = 0.1) +
  theme_void() +
  ggtitle('North')

p_central <- ggplot(data = bing_grid[2500:3000,] ) + 
  geom_sf(color = "gray60", 
          size = 0.1) +
  theme_void() +
  ggtitle('Central')

p_south <- ggplot(data = bing_grid %>% head(1500) ) + 
  geom_sf(color = "gray60", 
          size = 0.1) +
  theme_void() +
  ggtitle('South')

p_country | (p_north / p_central / p_south)
rm(p_country, p_north, p_central, p_south, bing_grid)
```

### Administrative areas

Read and describe administrative areas. Explain spatial data frames: geometry, projection, etc.

```{r}
#| warning: false
shp_pro <- read_sf("./data/shp/adm/provincias/Provincias.shp") %>% 
  st_simplify(preserveTopology =T,
              dTolerance = 1000) %>%  # 1km
  sf::st_make_valid() %>% 
  dplyr::select( -c(
    cir_sena, codregion, st_length_, Region
  ) ) %>% 
  st_transform(crs_default)

# checking for invalid polygons
st_is_valid(shp_pro)

shp_pro
```

```{r}
#| echo: false
ggplot(data = shp_pro) + 
  geom_sf(color = "gray60", 
          size = 0.1) +
  theme_void() +
  ggtitle('Provinces')
```
```{r}
#| warning: false
shp_reg <- read_sf("./data/shp/adm/regiones/Regional.shp") %>% 
  st_simplify(preserveTopology =T,
              dTolerance = 1000) %>%  # 1km
  sf::st_make_valid() %>% 
  dplyr::select( -c(
    cir_sena, st_area_sh, st_length_
  ) )
```


## Spatial indicators of human mobility

### Origin-based indicators

This measure is in relation to a baseline - percentage change and flow

```{r}
origin_df <- df20 %>% 
  filter(start_polygon_name != end_polygon_name) %>% 
  group_by(start_polygon_name) %>% 
  dplyr::summarise(
    mean_perchange = mean(percent_change, na.rm = T),
    mean_diff_flow = mean(n_difference, na.rm = T),
    sum_diff_flow = sum(n_difference, na.rm = T),
    mean_outflow = mean(n_crisis, na.rm = T),
    sum_outflow = sum(n_crisis, na.rm = T)
    ) %>% 
  ungroup()

tail(origin_df, 10)
```

### Destination-based indicators

```{r}
destination_df <- df20 %>% 
  filter(start_polygon_name != end_polygon_name) %>% 
  group_by(end_polygon_name) %>% 
  dplyr::summarise(
    mean_perchange = mean(percent_change, na.rm = T),
    mean_diff_flow = mean(n_difference, na.rm = T),
    sum_diff_flow = sum(n_difference, na.rm = T),
    mean_inflow = mean(n_crisis, na.rm = T),
    sum_inflow = sum(n_crisis, na.rm = T)
    ) %>% 
  ungroup()

tail(destination_df, 10)
```

### Intraflows

```{r}
origin_df <- df20 %>% 
  filter(start_polygon_name == end_polygon_name) %>% 
  group_by(start_polygon_name) %>% 
  dplyr::summarise(
    mean_perchange = mean(percent_change, na.rm = T),
    mean_diff_flow = mean(n_difference, na.rm = T),
    sum_diff_flow = sum(n_difference, na.rm = T),
    mean_intraflow = mean(n_crisis, na.rm = T),
    sum_intraflow = sum(n_crisis, na.rm = T)
    ) %>% 
  ungroup()

tail(origin_df, 10)
```

### Netflows

```{r}
# mean outflow by area
outflows_df <- df20 %>% 
  filter(start_polygon_name != end_polygon_name) %>% 
  group_by(start_polygon_name) %>% 
  dplyr::summarise(
    mean_outflow = mean(n_crisis, na.rm = T)
    ) %>% 
  ungroup()

# mean inflow by area
inflows_df <- df20 %>% 
  filter(start_polygon_name != end_polygon_name) %>% 
  group_by(end_polygon_name) %>% 
  dplyr::summarise(
    mean_inflow = mean(n_crisis, na.rm = T)
    ) %>% 
  ungroup()

# combine data frames
netflow_df <- cbind(inflows_df, outflows_df)

# mean netflow by area
netflow_df <- netflow_df %>% 
  mutate(
    mean_netflow = mean_inflow - mean_outflow
  ) %>% 
  select(start_polygon_name, end_polygon_name, mean_inflow, mean_outflow, mean_netflow)

head(netflow_df)
```

```{r}
#| warning: false

ggplot(data = netflow_df) +
  geom_density(aes(x = mean_netflow),
               alpha=0.5, 
               colour="darkblue", 
               linewidth = 2
               ) +
  theme_tufte()
```

## Mapping

Colour palettes

::: {.callout-note icon="false" appearance="simple"}
## Question 1

Why to create geovisualisations?
:::

For creating maps, cartography is important. A carefully crafted map can be an effective way of communicating complex information. Design issues include poor placement, size and readability of text and careless selection of colors. Have a look the style guide of the Journal of Maps for details.

::: callout-note
For colour palettes, we recommend the following resources:

-   the R packages `viridis` and `RColorBrewer`

-   the website [color brewer 2.0](https://colorbrewer2.org/#type=sequential&scheme=BuGn&n=3)

-   a publication by @crameri2020
:::

### Handling spatial data

```{r}
# set crs
crs_default = "EPSG:4326"
```

```{r}
df20 <- readRDS("./data/fb/movement_adm/2020_04.rds") %>% 
  mutate(GEOMETRY = NULL) %>% 
  dplyr::filter(country == "CL") %>% 
  st_as_sf(coords = c("start_lon", "start_lat"), 
                                      crs = crs_default)

glimpse(df20)
```

```{r}
#| warning: false
shp_pro <- read_sf("./data/shp/adm/provincias/Provincias.shp") %>% 
  st_simplify(preserveTopology =T,
              dTolerance = 1000) %>%  # 1km
  sf::st_make_valid() %>% 
  dplyr::select( -c(
    cir_sena, codregion, st_length_, Region
  ) ) %>% 
  st_transform(crs_default)

# checking for invalid polygons
st_is_valid(shp_pro)

glimpse(shp_pro)
```

Recompute <!--# recompute metrics to preserve the geometry -->

```{r}
# mean outflow by area
outflows_df <- df20 %>% 
  filter(start_polygon_name != end_polygon_name) %>% 
  group_by(start_polygon_name) %>% 
  dplyr::summarise(
    mean_outflow = mean(n_crisis, na.rm = T)
    ) %>% 
  ungroup()

# mean inflow by area
inflows_df <- df20 %>% 
  filter(start_polygon_name != end_polygon_name) %>% 
  group_by(end_polygon_name) %>% 
  dplyr::summarise(
    mean_inflow = mean(n_crisis, na.rm = T)
    ) %>% 
  ungroup() %>% 
  st_drop_geometry()

# combine data frames
netflow_df <- cbind(outflows_df, inflows_df)

# mean netflow by area
netflow_df <- netflow_df %>% 
  mutate(
    mean_netflow = mean_inflow - mean_outflow
  ) %>% 
  dplyr::select(start_polygon_name, mean_inflow, mean_outflow, mean_netflow, geometry) %>% 
  rename(
    polygon_name = start_polygon_name
  ) 

head(netflow_df)
```

```{r}
ggplot() + 
  geom_sf(data = shp_pro,
          color = "gray60", 
          size = 0.1) +
  geom_point(data = netflow_df,
    aes(geometry = geometry),
    stat = "sf_coordinates"
  ) 
```

```{r}
bbox_new <- st_bbox(shp_pro) # current bounding box

xrange <- bbox_new$xmax - bbox_new$xmin # range of x values
yrange <- bbox_new$ymax - bbox_new$ymin # range of y values

bbox_new[1] <- bbox_new[1] + (0.6 * xrange) # xmin - left
#bbox_new[3] <- bbox_new[3] + (0.5 * xrange) # xmax - right
#bbox_new[2] <- bbox_new[2] - (0.5 * yrange) # ymin - bottom
#bbox_new[4] <- bbox_new[4] + (0.5 * yrange) # ymax - top

bbox_new <- bbox_new %>%  # take the bounding box ...
  st_as_sfc() # ... and make it a sf polygon

ggplot() + 
  geom_sf(data = shp_pro,
          color = "gray60", 
          size = 0.1) +
  geom_point(data = netflow_df,
    aes(geometry = geometry),
    stat = "sf_coordinates",
    size = .1
  ) +
  coord_sf(xlim = st_coordinates(bbox_new)[c(1,2),1], # min & max of x values
           ylim = st_coordinates(bbox_new)[c(2,3),2]) + # min & max of y values
  theme_void()

```

```{r}
mob_indicators <- st_join(shp_pro, netflow_df)

netflow_df$check <- netflow_df$polygon_name %in% mob_indicators$polygon_name

netflow_df %>% select(polygon_name, check) %>% 
  filter(check == "FALSE")

```


```{r}
coordinates <- st_coordinates(netflow_df) 
netflow_df <- cbind(netflow_df, coordinates) %>% 
  rename(
    long = X, 
    lat = Y
  )

province_name <- c("ValparaÃ­so", "Magallanes")

for (area in 1:2) {
  long <- netflow_df %>% 
    st_drop_geometry() %>% 
    dplyr::filter(polygon_name == province_name[area]) %>% 
    select(long) %>% 
    as.numeric()
  
  lat <- netflow_df %>% 
    st_drop_geometry() %>%
    dplyr::filter(polygon_name == province_name[area]) %>% 
    select(lat) %>% 
    as.numeric()

  st_geometry(netflow_df[netflow_df$polygon_name == province_name[area], ]) <-  st_sfc(st_point(c( long * 0.98, lat * 1 )))
}

```

```{r}
mob_indicators <- st_join(shp_pro, netflow_df, 
                          st_intersects)

netflow_df$check <- netflow_df$polygon_name %in% mob_indicators$polygon_name

netflow_df %>% select(polygon_name, check) %>% 
  filter(check == "FALSE")
```



Join point-in-polygons


Overlay start points from the mobility dataset over the polygons. Extract start points from the linestring geometry and use that to create the spatial data frame for mobility.



### Choropleths

Choropleths are thematic maps. They are easy to create but also to get wrong. We will look at a set of the principles you can follow to create effective choropleth maps. Here three more questions to consider:

-   What is being plotted?

-   What is the target audience?

-   What degree of interactivity we want to offer?

Map flows - use code from uk migration paper

```{r}
# set categories
mob_indicators <- mob_indicators %>% 
  mutate(
    netflow_class = mean_netflow %>% cut(7, dig.lab = 3),
    inflow_class = mean_inflow %>% cut(7, dig.lab = 3),
    outflow_class = mean_outflow %>% cut(7, dig.lab = 3)
  ) 

# adjust labels for netflows
netflow_labels <- levels(mob_indicators$netflow_class)
netflow_labels <- gsub("\\(|\\]", "", netflow_labels)
levels(mob_indicators$netflow_class) <- netflow_labels

# adjust labels for inflows
inflow_labels <- levels(mob_indicators$inflow_class)
inflow_labels <- gsub("\\(|\\]", "", inflow_labels)
levels(mob_indicators$inflow_class) <- inflow_labels

# adjust labels for netflows
outflow_labels <- levels(mob_indicators$outflow_class)
outflow_labels <- gsub("\\(|\\]", "", outflow_labels)
levels(mob_indicators$outflow_class) <- outflow_labels

# change geometry
shp_reg <- shp_reg %>% st_transform(crs_default)
```

```{r}
# map netflows
netflow_plot <- ggplot(data = mob_indicators, aes(fill = netflow_class)) +
  geom_sf(col = "white", size = .1) +
  coord_sf() +
  scale_fill_brewer(palette = "RdBu", direction = -1) +
  scale_color_manual(labels = net_classes) +
  theme_map() +
  theme(plot.title = element_text(size = 22, face = "bold"),
        legend.position = "none") +
  labs(title = "(a) Netflow",
       fill = "%") +
  theme_void() + 
  geom_sf(data = shp_reg,
          col = "grey70", 
          size = .5,
          fill = "transparent") +
  coord_sf(xlim = st_coordinates(bbox_new)[c(1,2),1], 
           ylim = st_coordinates(bbox_new)[c(2,3),2]) 

# map inflows
inflow_plot <- ggplot(data = mob_indicators, aes(fill = inflow_class)) +
  geom_sf(col = "white", size = .1) +
  coord_sf() +
  scale_fill_brewer(palette = "PuRd", direction = 1) +
  theme_map() +
  theme(plot.title = element_text(size = 22, face = "bold"),
        legend.position = "none") +
  labs(title = "(b) Inflow",
       fill = "%") +
  theme_void() + 
  geom_sf(data = shp_reg,
          col = "grey70", 
          size = .5,
          fill = "transparent") +
  coord_sf(xlim = st_coordinates(bbox_new)[c(1,2),1], 
           ylim = st_coordinates(bbox_new)[c(2,3),2]) 

# map outflows
outflow_plot <- ggplot(data = mob_indicators, aes(fill = outflow_class)) +
  geom_sf(col = "white", size = .1) +
  coord_sf() +
  scale_fill_brewer(palette = "PuBu", direction = 1) +
  theme_map() +
  theme(plot.title = element_text(size = 22, face = "bold"),
        legend.position = "none") +
  labs(title = "(b) Outflow",
       fill = "%") +
  theme_void() +
    geom_sf(data = shp_reg,
          col = "grey70", 
          size = .5,
          fill = "transparent") +
  coord_sf(xlim = st_coordinates(bbox_new)[c(1,2),1], 
           ylim = st_coordinates(bbox_new)[c(2,3),2]) 

netflow_plot + inflow_plot + outflow_plot
```

<!--# Use rates - need to aggregate the FB for individual months -->

### Interactive mapping

### Flow mapping

<!--# Common concepts -->

<!--# There are several concepts relevant to understanding the data sets. First of all, we construct maps using two different methods of identifying locations: tiles and administrative polygons. -->

<!--#  The Bing Maps Tile System defines a series of grids at different resolution levels over a rectangular projection of the world (Schwartz 2018). Each level is constructed by dividing the previous level into fourths. We typically use Bing tile levels 13 through 16, where level 13 results in tiles that are about 4.9 x 4.9 km at the Equator. The other method we use for identifying a location is administrative polygons, which define the political and geographic boundaries of countries, states, provinces, counties, cities, and more. -->

<!--#  When generating a map for a crisis event, we specify a rectangular bounding box around the most directly affected area. The different map calculations, described in the following sections, are done relative to this region, and, for most of the maps, only data within this region is included. Most of the map types are based on counting events that occur within a time interval, which is frequently 8 or 24 hours. The time interval determines what data is included in a calculation as well as the minimum frequency with which new maps are generated.  -->
